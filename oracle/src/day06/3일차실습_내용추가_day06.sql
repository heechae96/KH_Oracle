CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

DESC USER_GRADE;

SELECT * FROM USER_GRADE;

INSERT INTO USER_GRADE VALUES(10, '일반회원');
INSERT INTO USER_GRADE VALUES(20, '우수회원');
INSERT INTO USER_GRADE VALUES(30, '특별회원');

CREATE TABLE USER_FOREIGNKEY(
    USER_NO NUMBER CONSTRAINT USER_NO_PK PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER CONSTRAINT GRADE_CODE_FK REFERENCES USER_GRADE(GRADE_CODE)
    -- '외래키'라도 부모 컬럼명과 자식 컬럼명을 일치시킬 필요는 없음
);

SELECT * FROM USER_FOREIGNKEY;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_FOREIGNKEY';

INSERT INTO USER_FOREIGNKEY
VALUES(1, 'user01', 'pass01', '일용자', '남', 'user01@iei.com', 10);
INSERT INTO USER_FOREIGNKEY
VALUES(2, 'user02', 'pass02', '이용자', '남', 'user02@iei.com', 20);
INSERT INTO USER_FOREIGNKEY
VALUES(3, 'user03', 'pass03', '삼용자', '남', 'user03@iei.com', 30);
-- 제약때문에 들어가지 않음
INSERT INTO USER_FOREIGNKEY
VALUES(4, 'user04', 'pass04', '사용자', '남', 'user04@iei.com', 40);


-- 제약 조건 걸려있는 부모테이블 레코드 지워보기
DELETE FROM USER_GRADE
WHERE GRADE_CODE = 10;
-- 못지운다.. 지우는 방법, 즉 삭제 옵션이 2개 존재
-- 1. ON DELETE SET NULL; -> 자식테이블 데이터를 NULL로 바꿔줌
-- 2. ON DELETE CASCADE; -> 자식테이블 데이터도 지워줌
ALTER TABLE USER_FOREIGNKEY
DROP CONSTRAINT GRADE_CODE_FK;
COMMIT;
ROLLBACK;

-- USER_FOREIGNKEY테이블에
ALTER TABLE USER_FOREIGNKEY
-- 제약 조건을 더한다. GRADE_CODE속성을 외래키로 설정하고 그 이름을 GRADE_CODE_FK한다. USER_GRADE테이블에 GRADE_CODE)를 참조
ADD CONSTRAINT GRADE_CODE_FK FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
-- 부모테이블이 지워지면 값을 NULL로 바꾸겠다
ON DELETE SET NULL;

-- 3줄 요약
-- 1. 외래키(자식테이블)가 참조하는 부모테이블 컬럼 데이터는 기본적으로 지워지지 않는다
-- 2. ON DELETE SET NULL 옵션은 부모테이블 데이터를 지워주고 자식 테이블 데이터는 NULL로 해준다
-- 3. ON DELETE CASCADE 옵션은 부모테이블 데이터를 지워주고 자식 데이터도 지워준다






